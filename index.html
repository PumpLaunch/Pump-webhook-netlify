<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>CryptoFlux Pro - Pump.fun Sniper</title>
  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
  <style>
    :root {
      --bg: #0a0e27;
      --card: #131937;
      --border: #2a3457;
      --text: #ffffff;
      --text-secondary: #8892b0;
      --green: #00ff88;
      --purple: #9945ff;
      --red: #ff3366;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, sans-serif;
      line-height: 1.5;
      padding: 16px;
    }
    .container { max-width: 700px; margin: 0 auto; }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }
    .logo {
      font-size: 1.6rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--purple), var(--green));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
    }
    .btn-primary {
      background: linear-gradient(135deg, var(--purple), var(--green));
      color: white;
    }
    .btn-danger {
      background: var(--red);
      color: white;
    }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 1.2rem;
      margin-bottom: 1.2rem;
    }
    .signal-item {
      background: rgba(153, 69, 255, 0.1);
      border-left: 3px solid var(--purple);
      padding: 12px;
      margin: 8px 0;
      border-radius: 8px;
    }
    .status {
      font-family: monospace;
      color: var(--text-secondary);
      margin-top: 12px;
      font-size: 0.9rem;
    }
    label {
      display: block;
      margin: 8px 0 4px;
      font-weight: 500;
    }
    input, select {
      width: 100%;
      padding: 6px;
      background: rgba(0,0,0,0.3);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: white;
      margin-bottom: 8px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="logo">CryptoFlux Pro</div>
      <button id="connectBtn" class="btn btn-primary" disabled>Connecter Wallet</button>
    </div>

    <div id="app" style="display:none;">
      <div class="card">
        <div><strong>Adresse :</strong> <span id="address">...</span></div>
        <div><strong>Solde :</strong> <span id="balance">Chargement...</span> SOL</div>
        <div><strong>R√©seau :</strong> Mainnet</div>
      </div>

      <div class="card">
        <h3>‚öôÔ∏è Param√®tres</h3>
        <label>Achat (SOL):</label>
        <input type="number" id="buyAmount" value="0.05" step="0.01" min="0.01">
        
        <label>Profit cible (%):</label>
        <input type="number" id="profitTarget" value="50" min="1" placeholder="Ex: 50 = +50%">
        
        <label>√Çge max (sec):</label>
        <input type="number" id="maxAge" value="300" min="10">
        
        <label>Marketcap min ($):</label>
        <input type="number" id="minMarketcap" value="10000" min="0">
        
        <label>D√©tenteurs min:</label>
        <input type="number" id="minHolders" value="50" min="1">
        
        <label>Liquidit√© min (SOL):</label>
        <input type="number" id="minLiquidity" value="5" min="0.1" step="0.1">
        
        <label>Frais prioritaires:</label>
        <select id="priorityFee">
          <option value="100000">√âlev√©</option>
          <option value="1000000" selected>Turbo</option>
          <option value="5000000">Extr√™me</option>
        </select>
        
        <button id="toggleScan" class="btn btn-primary" style="margin-top: 12px;">‚ñ∂Ô∏è D√©marrer le Scan</button>
      </div>

      <div class="card">
        <h3>üîî Positions actives</h3>
        <div id="positions">Aucune position</div>
      </div>
    </div>

    <div id="status" class="status">V√©rification du wallet...</div>
  </div>

  <script>
    // === CONFIGURATION ===
    const HELIUS_API_KEY = '8f852e97-a557-4065-be74-cc2a6547cd28';
    const HELIUS_RPC_URL = `https://mainnet.helius-rpc.com/?api-key=${HELIUS_API_KEY}`;
    const WEBHOOK_URL = 'https://pump-webhook-netlify.vercel.app/api/pump-signal';
    const RPC_URL = HELIUS_RPC_URL;
    const PUMP_PROGRAM_ID = '6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P';
    const PUMP_FEE_RECIPIENT = 'CebN5WGQ4jvEPvsVU4EoHEpgzq1VV7AbicfhtW4xC9iM';
    const RENT_SYSVAR = 'SysvarRent111111111111111111111111111111111';
    const BUY_DISCRIMINATOR = [0x66, 0x06, 0x3d, 0x12, 0x01, 0xda, 0xeb, 0xea];
    const SELL_DISCRIMINATOR = [0x66, 0x06, 0x3d, 0x12, 0x02, 0xda, 0xeb, 0xea];

    // === √âl√©ments DOM ===
    const statusEl = document.getElementById('status');
    const connectBtn = document.getElementById('connectBtn');
    const toggleScanBtn = document.getElementById('toggleScan');
    const addressEl = document.getElementById('address');
    const balanceEl = document.getElementById('balance');
    const positionsEl = document.getElementById('positions');
    const appEl = document.getElementById('app');

    let provider = null;
    let connection = null;
    let isScanning = false;
    let scanInterval = null;
    let lastMint = null;
    const activePositions = new Map();

    // === UTILITAIRES ===
    function log(msg) {
      console.log('[CryptoFlux]', msg);
      statusEl.textContent = msg;
    }

    function getProvider() {
      if (typeof window === 'undefined') return null;
      if (window.phantom?.solana?.isPhantom) return window.phantom.solana;
      if (window.solana) return window.solana;
      return null;
    }

    function encodeU64(value) {
      const buffer = new ArrayBuffer(8);
      const view = new DataView(buffer);
      view.setBigUint64(0, BigInt(value), true);
      return new Uint8Array(buffer);
    }

    async function getBalance(publicKey) {
      try {
        const bal = await connection.getBalance(publicKey);
        return bal / solanaWeb3.LAMPORTS_PER_SOL;
      } catch (err) {
        console.warn("‚ö†Ô∏è Impossible de charger le solde:", err.message);
        return null;
      }
    }

    async function getTokenPrice(mintAddress) {
      try {
        const res = await fetch(HELIUS_RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 'price',
            method: 'getTokenMetadata',
            params: { mint: mintAddress }
          })
        });
        const data = await res.json();
        const metadata = data.result;

        if (!metadata || !metadata.pumpFun) return null;

        const totalSupply = metadata.tokenInfo?.supply ? 
          parseInt(metadata.tokenInfo.supply) / Math.pow(10, metadata.tokenInfo.decimals || 9) : 0;
        const virtualSolReserves = metadata.pumpFun.virtualSolReserves || 0;
        const pricePerToken = totalSupply > 0 ? virtualSolReserves / totalSupply : 0;

        return {
          priceSol: pricePerToken,
          marketcapUsd: pricePerToken * virtualSolReserves * 150
        };
      } catch (err) {
        console.error("Erreur prix:", err);
        return null;
      }
    }

    // === CONNEXION WALLET CORRIG√âE ===
    async function connectWallet() {
      const walletProvider = getProvider();
      if (!walletProvider) {
        log("‚ùå Ouvrez cette page dans l'app Phantom ‚Üí Browser");
        return;
      }

      try {
        // Force la d√©connexion pour √©viter les √©tats fant√¥mes
        if (typeof walletProvider.disconnect === 'function') {
          await walletProvider.disconnect().catch(() => {});
        }

        log("Connexion en cours...");
        const { publicKey } = await walletProvider.connect();

        if (!publicKey) {
          log("‚ùå Aucune cl√© publique retourn√©e");
          return;
        }

        const pubKeyStr = publicKey.toString();
        connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
        provider = walletProvider;

        addressEl.textContent = `${pubKeyStr.slice(0,6)}...${pubKeyStr.slice(-4)}`;
        appEl.style.display = 'block';

        const balance = await getBalance(publicKey);
        balanceEl.textContent = balance !== null ? balance.toFixed(4) : "‚Äî";

        log("‚úÖ Connect√© !");
      } catch (err) {
        console.error(err);
        log(`‚ùå ${err.message || 'Annul√©'}`);
      }
    }

    // === ACHAT AVEC FILTRES ===
    async function buyToken(mintAddress) {
      if (!provider || !connection || !provider.publicKey) {
        log("‚ùå Wallet non connect√©");
        return;
      }

      const minHolders = parseInt(document.getElementById('minHolders').value) || 50;
      const minLiquidity = parseFloat(document.getElementById('minLiquidity').value) || 5;

      try {
        log(`üîç Analyse du token ${mintAddress}...`);

        const priceData = await getTokenPrice(mintAddress);
        if (!priceData || priceData.priceSol <= 0) {
          log("‚ùå Liquidit√© nulle ou m√©tadonn√©es introuvables");
          return;
        }

        const holdersRes = await fetch(HELIUS_RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 'holders',
            method: 'getTokenHolders',
            params: { mint: mintAddress, limit: 1000 }
          })
        });
        const holdersData = await holdersRes.json();
        const holderCount = holdersData.result?.length || 0;

        if (holderCount < minHolders) {
          log(`‚ùå Trop peu de d√©tenteurs (${holderCount} < ${minHolders})`);
          return;
        }

        if (priceData.priceSol < minLiquidity) {
          log(`‚ùå Liquidit√© insuffisante (${priceData.priceSol.toFixed(2)} SOL < ${minLiquidity} SOL)`);
          return;
        }

        log(`‚úÖ Token prometteur ! D√©tenteurs: ${holderCount}, Liquidit√©: ${priceData.priceSol.toFixed(2)} SOL`);

        const buyAmountSol = parseFloat(document.getElementById('buyAmount').value) || 0.05;
        const priorityFeeLamports = parseInt(document.getElementById('priorityFee').value) || 1000000;
        const buyAmountLamports = buyAmountSol * solanaWeb3.LAMPORTS_PER_SOL;

        const [pumpGlobal] = solanaWeb3.PublicKey.findProgramAddressSync(
          [Buffer.from("global")],
          new solanaWeb3.PublicKey(PUMP_PROGRAM_ID)
        );
        const [pumpTokenAccount] = solanaWeb3.PublicKey.findProgramAddressSync(
          [Buffer.from("token_account"), new solanaWeb3.PublicKey(mintAddress).toBuffer()],
          new solanaWeb3.PublicKey(PUMP_PROGRAM_ID)
        );
        const [userTokenAccount] = solanaWeb3.PublicKey.findProgramAddressSync(
          [
            provider.publicKey.toBuffer(),
            new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA").toBuffer(),
            new solanaWeb3.PublicKey(mintAddress).toBuffer()
          ],
          new solanaWeb3.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL")
        );

        const transaction = new solanaWeb3.Transaction();
        transaction.feePayer = provider.publicKey;
        const { blockhash } = await connection.getLatestBlockhash();
        transaction.recentBlockhash = blockhash;

        transaction.add(
          solanaWeb3.ComputeBudgetProgram.setComputeUnitLimit({ units: 200000 }),
          solanaWeb3.ComputeBudgetProgram.setComputeUnitPrice({ microLamports: priorityFeeLamports })
        );

        const userTokenAccountInfo = await connection.getAccountInfo(userTokenAccount);
        if (!userTokenAccountInfo) {
          transaction.add(
            solanaWeb3.SystemProgram.createAccount({
              fromPubkey: provider.publicKey,
              newAccountPubkey: userTokenAccount,
              lamports: await connection.getMinimumBalanceForRentExemption(165),
              space: 165,
              programId: new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA")
            }),
            new solanaWeb3.TransactionInstruction({
              keys: [
                { pubkey: userTokenAccount, isSigner: false, isWritable: true },
                { pubkey: new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"), isSigner: false, isWritable: false },
                { pubkey: provider.publicKey, isSigner: true, isWritable: false }
              ],
              programId: new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
               Buffer.from([9])
            })
          );
        }

        const buyInstruction = new solanaWeb3.TransactionInstruction({
          keys: [
            { pubkey: provider.publicKey, isSigner: true, isWritable: true },
            { pubkey: pumpGlobal, isSigner: false, isWritable: false },
            { pubkey: new solanaWeb3.PublicKey(PUMP_FEE_RECIPIENT), isSigner: false, isWritable: true },
            { pubkey: pumpTokenAccount, isSigner: false, isWritable: true },
            { pubkey: userTokenAccount, isSigner: false, isWritable: true },
            { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false },
            { pubkey: new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"), isSigner: false, isWritable: false },
            { pubkey: new solanaWeb3.PublicKey(RENT_SYSVAR), isSigner: false, isWritable: false }
          ],
          programId: new solanaWeb3.PublicKey(PUMP_PROGRAM_ID),
           Buffer.concat([
            Buffer.from(BUY_DISCRIMINATOR),
            Buffer.from(encodeU64(buyAmountLamports))
          ])
        });

        transaction.add(buyInstruction);
        log("Demande de signature dans Phantom...");
        const signed = await provider.signTransaction(transaction);
        const txid = await connection.sendRawTransaction(signed.serialize());
        log(`‚úÖ Achat envoy√© ! https://solscan.io/tx/${txid}`);

        const profitTarget = parseFloat(document.getElementById('profitTarget').value) || 50;
        const targetPrice = priceData.priceSol * (1 + profitTarget / 100);

        activePositions.set(mintAddress, {
          buyPrice: priceData.priceSol,
          amountSol: buyAmountSol,
          targetPrice: targetPrice,
          txid: txid
        });

        updatePositionsUI();
        monitorPositionForSale(mintAddress);

      } catch (err) {
        console.error(err);
        log(`‚ùå √âchec analyse/achat: ${err.message || err}`);
        alert(`‚ùå √âchec: ${err.message || 'Erreur inconnue'}`);
      }
    }

    // === REVENTE ===
    async function sellToken(mintAddress) {
      if (!provider || !connection || !provider.publicKey) {
        log("‚ùå Wallet non connect√©");
        return;
      }

      const position = activePositions.get(mintAddress);
      if (!position) {
        log("‚ùå Position introuvable");
        return;
      }

      const priorityFeeLamports = parseInt(document.getElementById('priorityFee').value) || 1000000;

      try {
        log(`Pr√©paration vente pour ${mintAddress}...`);

        const [pumpGlobal] = solanaWeb3.PublicKey.findProgramAddressSync(
          [Buffer.from("global")],
          new solanaWeb3.PublicKey(PUMP_PROGRAM_ID)
        );
        const [pumpTokenAccount] = solanaWeb3.PublicKey.findProgramAddressSync(
          [Buffer.from("token_account"), new solanaWeb3.PublicKey(mintAddress).toBuffer()],
          new solanaWeb3.PublicKey(PUMP_PROGRAM_ID)
        );
        const [userTokenAccount] = solanaWeb3.PublicKey.findProgramAddressSync(
          [
            provider.publicKey.toBuffer(),
            new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA").toBuffer(),
            new solanaWeb3.PublicKey(mintAddress).toBuffer()
          ],
          new solanaWeb3.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL")
        );

        const transaction = new solanaWeb3.Transaction();
        transaction.feePayer = provider.publicKey;
        const { blockhash } = await connection.getLatestBlockhash();
        transaction.recentBlockhash = blockhash;

        transaction.add(
          solanaWeb3.ComputeBudgetProgram.setComputeUnitLimit({ units: 200000 }),
          solanaWeb3.ComputeBudgetProgram.setComputeUnitPrice({ microLamports: priorityFeeLamports })
        );

        const sellInstruction = new solanaWeb3.TransactionInstruction({
          keys: [
            { pubkey: provider.publicKey, isSigner: true, isWritable: true },
            { pubkey: pumpGlobal, isSigner: false, isWritable: false },
            { pubkey: new solanaWeb3.PublicKey(PUMP_FEE_RECIPIENT), isSigner: false, isWritable: true },
            { pubkey: pumpTokenAccount, isSigner: false, isWritable: true },
            { pubkey: userTokenAccount, isSigner: false, isWritable: true },
            { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false },
            { pubkey: new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"), isSigner: false, isWritable: false },
            { pubkey: new solanaWeb3.PublicKey(RENT_SYSVAR), isSigner: false, isWritable: false }
          ],
          programId: new solanaWeb3.PublicKey(PUMP_PROGRAM_ID),
           Buffer.concat([
            Buffer.from(SELL_DISCRIMINATOR)
          ])
        });

        transaction.add(sellInstruction);
        log("Demande de signature pour vente...");
        const signed = await provider.signTransaction(transaction);
        const txid = await connection.sendRawTransaction(signed.serialize());
        log(`‚úÖ Vente envoy√©e ! https://solscan.io/tx/${txid}`);
        alert(`‚úÖ Vente r√©ussie !\nhttps://solscan.io/tx/${txid}`);

        activePositions.delete(mintAddress);
        updatePositionsUI();

      } catch (err) {
        console.error(err);
        log(`‚ùå √âchec vente: ${err.message || err}`);
        alert(`‚ùå √âchec vente: ${err.message || 'Erreur inconnue'}`);
      }
    }

    // === SURVEILLANCE REVENTE ===
    async function monitorPositionForSale(mint) {
      if (!activePositions.has(mint)) return;

      const checkPrice = async () => {
        const position = activePositions.get(mint);
        if (!position || !position.targetPrice) {
          setTimeout(checkPrice, 5000);
          return;
        }

        const priceData = await getTokenPrice(mint);
        if (priceData && priceData.priceSol >= position.targetPrice) {
          log(`üéØ Profit atteint pour ${mint} ! Vente automatique...`);
          sellToken(mint);
        } else {
          setTimeout(checkPrice, 5000);
        }
      };

      checkPrice();
    }

    // === UI POSITIONS ===
    function updatePositionsUI() {
      if (activePositions.size === 0) {
        positionsEl.innerHTML = "Aucune position";
        return;
      }

      let html = '';
      for (const [mint, pos] of activePositions.entries()) {
        const currentProfit = pos.buyPrice ? ((pos.targetPrice / pos.buyPrice - 1) * 100).toFixed(1) : '?';
        html += `
          <div class="signal-item">
            <strong>${mint.slice(0,8)}...</strong><br>
            Achat: ${pos.buyPrice ? pos.buyPrice.toFixed(6) : '?'} SOL<br>
            Cible: ${pos.targetPrice ? pos.targetPrice.toFixed(6) : '?'} SOL (+${currentProfit}%)<br>
            Tx: <a href="https://solscan.io/tx/${pos.txid}" target="_blank" style="color:#00ff88;">voir</a><br>
            <button class="btn btn-danger" onclick="sellToken('${mint}')">Vendre maintenant</button>
          </div>
        `;
      }
      positionsEl.innerHTML = html;
    }

    // === SCANNER ===
    async function pollForSignals() {
      try {
        const res = await fetch(WEBHOOK_URL);
        const data = await res.json();
        if (data.mint && data.mint !== lastMint) {
          lastMint = data.mint;
          buyToken(data.mint);
        }
      } catch (err) {
        console.error("Polling √©chou√©:", err);
      }
    }

    // === TOGGLE SCAN ===
    function toggleScan() {
      if (isScanning) {
        clearInterval(scanInterval);
        isScanning = false;
        toggleScanBtn.textContent = "‚ñ∂Ô∏è D√©marrer le Scan";
        log("‚èπÔ∏è Scan arr√™t√©");
      } else {
        isScanning = true;
        toggleScanBtn.textContent = "‚èπÔ∏è Arr√™ter le Scan";
        scanInterval = setInterval(pollForSignals, 3000);
        log("üîç Scan activ√©");
      }
    }

    // === INITIALISATION ===
    // D√©tecte le wallet apr√®s un court d√©lai
    setTimeout(() => {
      const provider = getProvider();
      if (provider) {
        log("‚úÖ Wallet d√©tect√© !");
        connectBtn.disabled = false;
        connectBtn.onclick = connectWallet;
      } else {
        log("‚ùå Ouvrez cette page dans l'app Phantom ‚Üí Browser");
      }
    }, 1000);

    toggleScanBtn.onclick = toggleScan;
    window.sellToken = sellToken;
  </script>
</body>
</html>
