<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>CryptoFlux Pro - Pump Sniper</title>
  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
  <style>
    :root {
      --bg: #0a0e27;
      --card: #131937;
      --border: #2a3457;
      --text: #ffffff;
      --green: #00ff88;
      --purple: #9945ff;
      --red: #ff3366;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, sans-serif;
      line-height: 1.5;
      padding: 16px;
    }
    .container { max-width: 700px; margin: 0 auto; }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }
    .logo {
      font-size: 1.6rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--purple), var(--green));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
    }
    .btn-primary {
      background: linear-gradient(135deg, var(--purple), var(--green));
      color: white;
    }
    .btn-danger {
      background: var(--red);
      color: white;
    }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 1.2rem;
      margin-bottom: 1.2rem;
    }
    .status {
      font-family: monospace;
      color: #8892b0;
      margin-top: 12px;
      font-size: 0.9rem;
    }
    label {
      display: block;
      margin: 8px 0 4px;
      font-weight: 500;
    }
    input, select {
      width: 100%;
      padding: 6px;
      background: rgba(0,0,0,0.3);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: white;
      margin-bottom: 8px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="logo">CryptoFlux Pro</div>
      <button id="connectBtn" class="btn btn-primary" disabled>Connecter Wallet</button>
    </div>

    <div id="app" style="display:none;">
      <div class="card">
        <div><strong>Adresse :</strong> <span id="address">...</span></div>
        <div><strong>Solde :</strong> ‚Äî SOL</div>
        <div><strong>R√©seau :</strong> Mainnet</div>
      </div>

      <div class="card">
        <h3>‚öôÔ∏è Param√®tres</h3>
        <label>Achat (SOL):</label>
        <input type="number" id="buyAmount" value="0.05" step="0.01" min="0.01">
        
        <label>Profit cible (%):</label>
        <input type="number" id="profitTarget" value="50" min="1">
        
        <label>D√©tenteurs min:</label>
        <input type="number" id="minHolders" value="50" min="1">
        
        <label>Liquidit√© min (SOL):</label>
        <input type="number" id="minLiquidity" value="5" min="0.1" step="0.1">
        
        <label>Frais prioritaires:</label>
        <select id="priorityFee">
          <option value="100000">√âlev√©</option>
          <option value="1000000" selected>Turbo</option>
          <option value="5000000">Extr√™me</option>
        </select>
        
        <button id="toggleScan" class="btn btn-primary" style="margin-top: 12px;">‚ñ∂Ô∏è D√©marrer le Scan</button>
      </div>
    </div>

    <div id="status" class="status">V√©rification du wallet...</div>
  </div>

  <script>
    // === CONFIGURATION ===
    const HELIUS_API_KEY = '8f852e97-a557-4065-be74-cc2a6547cd28';
    const HELIUS_RPC_URL = `https://rpc.helius.xyz/?api-key=${HELIUS_API_KEY}`;
    const WEBHOOK_URL = 'https://pump-webhook-netlify.vercel.app/api/pump-signal';
    
    const PUMP_PROGRAM_ID = '6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P';
    const PUMP_FEE_RECIPIENT = 'CebN5WGQ4jvEPvsVU4EoHEpgzq1VV7AbicfhtW4xC9iM';
    const RENT_SYSVAR = 'SysvarRent111111111111111111111111111111111';
    const BUY_DISCRIMINATOR = [0x66, 0x06, 0x3d, 0x12, 0x01, 0xda, 0xeb, 0xea];
    const SELL_DISCRIMINATOR = [0x66, 0x06, 0x3d, 0x12, 0x02, 0xda, 0xeb, 0xea];

    // === √âl√©ments DOM ===
    const statusEl = document.getElementById('status');
    const connectBtn = document.getElementById('connectBtn');
    const toggleScanBtn = document.getElementById('toggleScan');
    const addressEl = document.getElementById('address');
    const appEl = document.getElementById('app');

    let provider = null;
    let connection = null;
    let isScanning = false;
    let scanInterval = null;
    let lastMint = null;
    const activePositions = new Map();

    // === UTILITAIRES ===
    function log(msg) {
      console.log('[CryptoFlux]', msg);
      statusEl.textContent = msg;
    }

    function encodeU64(value) {
      const buffer = new ArrayBuffer(8);
      const view = new DataView(buffer);
      view.setBigUint64(0, BigInt(value), true);
      return new Uint8Array(buffer);
    }

    async function getTokenData(mintAddress) {
      try {
        const res = await fetch(HELIUS_RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 'token-data',
            method: 'getTokenMetadata',
            params: { mint: mintAddress }
          })
        });
        const data = await res.json();
        const metadata = data.result;

        if (!metadata || !metadata.pumpFun) return null;

        const totalSupply = metadata.tokenInfo?.supply ? 
          parseInt(metadata.tokenInfo.supply) / Math.pow(10, metadata.tokenInfo.decimals || 9) : 0;
        const virtualSolReserves = metadata.pumpFun.virtualSolReserves || 0;
        const pricePerToken = totalSupply > 0 ? virtualSolReserves / totalSupply : 0;

        // R√©cup√©rer les d√©tenteurs
        const holdersRes = await fetch(HELIUS_RPC_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 'holders',
            method: 'getTokenHolders',
            params: { mint: mintAddress, limit: 1000 }
          })
        });
        const holdersData = await holdersRes.json();
        const holderCount = holdersData.result?.length || 0;

        return {
          priceSol: pricePerToken,
          holderCount: holderCount,
          liquiditySol: virtualSolReserves
        };
      } catch (err) {
        console.error("Erreur r√©cup√©ration donn√©es:", err);
        return null;
      }
    }

    // === CONNEXION WALLET ===
    if (window.phantom?.solana?.isPhantom) {
      log("‚úÖ Wallet d√©tect√© !");
      connectBtn.disabled = false;
      connectBtn.onclick = async () => {
        try {
          log("Connexion en cours...");
          provider = window.phantom.solana;
          if (provider.disconnect) await provider.disconnect().catch(() => {});
          
          const { publicKey } = await provider.connect();
          const pubKeyStr = publicKey.toString();
          
          connection = new solanaWeb3.Connection(HELIUS_RPC_URL, 'confirmed');
          addressEl.textContent = `${pubKeyStr.slice(0,6)}...${pubKeyStr.slice(-4)}`;
          appEl.style.display = 'block';
          log("‚úÖ Connect√© !");
        } catch (err) {
          log(`‚ùå ${err.message || 'Annul√©'}`);
        }
      };
    } else {
      log("‚ùå Ouvrez cette page dans l'app Phantom ‚Üí Browser");
    }

    // === ACHAT ===
    async function buyToken(mintAddress) {
      if (!provider || !connection) {
        log("‚ùå Wallet non connect√©");
        return;
      }

      const minHolders = parseInt(document.getElementById('minHolders').value) || 50;
      const minLiquidity = parseFloat(document.getElementById('minLiquidity').value) || 5;

      log(`üîç Analyse du token ${mintAddress}...`);
      const tokenData = await getTokenData(mintAddress);
      
      if (!tokenData) {
        log("‚ùå Donn√©es introuvables");
        return;
      }

      if (tokenData.holderCount < minHolders) {
        log(`‚ùå Trop peu de d√©tenteurs (${tokenData.holderCount} < ${minHolders})`);
        return;
      }

      if (tokenData.liquiditySol < minLiquidity) {
        log(`‚ùå Liquidit√© insuffisante (${tokenData.liquiditySol.toFixed(2)} SOL < ${minLiquidity} SOL)`);
        return;
      }

      log(`‚úÖ Token prometteur ! D√©tenteurs: ${tokenData.holderCount}, Liquidit√©: ${tokenData.liquiditySol.toFixed(2)} SOL`);

      const buyAmountSol = parseFloat(document.getElementById('buyAmount').value) || 0.05;
      const priorityFeeLamports = parseInt(document.getElementById('priorityFee').value) || 1000000;
      const buyAmountLamports = buyAmountSol * solanaWeb3.LAMPORTS_PER_SOL;

      try {
        const [pumpGlobal] = solanaWeb3.PublicKey.findProgramAddressSync(
          [Buffer.from("global")],
          new solanaWeb3.PublicKey(PUMP_PROGRAM_ID)
        );
        const [pumpTokenAccount] = solanaWeb3.PublicKey.findProgramAddressSync(
          [Buffer.from("token_account"), new solanaWeb3.PublicKey(mintAddress).toBuffer()],
          new solanaWeb3.PublicKey(PUMP_PROGRAM_ID)
        );
        const [userTokenAccount] = solanaWeb3.PublicKey.findProgramAddressSync(
          [
            provider.publicKey.toBuffer(),
            new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA").toBuffer(),
            new solanaWeb3.PublicKey(mintAddress).toBuffer()
          ],
          new solanaWeb3.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL")
        );

        const transaction = new solanaWeb3.Transaction();
        transaction.feePayer = provider.publicKey;
        const { blockhash } = await connection.getLatestBlockhash();
        transaction.recentBlockhash = blockhash;

        transaction.add(
          solanaWeb3.ComputeBudgetProgram.setComputeUnitLimit({ units: 200000 }),
          solanaWeb3.ComputeBudgetProgram.setComputeUnitPrice({ microLamports: priorityFeeLamports })
        );

        const userTokenAccountInfo = await connection.getAccountInfo(userTokenAccount);
        if (!userTokenAccountInfo) {
          transaction.add(
            solanaWeb3.SystemProgram.createAccount({
              fromPubkey: provider.publicKey,
              newAccountPubkey: userTokenAccount,
              lamports: await connection.getMinimumBalanceForRentExemption(165),
              space: 165,
              programId: new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA")
            }),
            new solanaWeb3.TransactionInstruction({
              keys: [
                { pubkey: userTokenAccount, isSigner: false, isWritable: true },
                { pubkey: new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"), isSigner: false, isWritable: false },
                { pubkey: provider.publicKey, isSigner: true, isWritable: false }
              ],
              programId: new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
               Buffer.from([9])
            })
          );
        }

        const buyInstruction = new solanaWeb3.TransactionInstruction({
          keys: [
            { pubkey: provider.publicKey, isSigner: true, isWritable: true },
            { pubkey: pumpGlobal, isSigner: false, isWritable: false },
            { pubkey: new solanaWeb3.PublicKey(PUMP_FEE_RECIPIENT), isSigner: false, isWritable: true },
            { pubkey: pumpTokenAccount, isSigner: false, isWritable: true },
            { pubkey: userTokenAccount, isSigner: false, isWritable: true },
            { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false },
            { pubkey: new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"), isSigner: false, isWritable: false },
            { pubkey: new solanaWeb3.PublicKey(RENT_SYSVAR), isSigner: false, isWritable: false }
          ],
          programId: new solanaWeb3.PublicKey(PUMP_PROGRAM_ID),
           Buffer.concat([
            Buffer.from(BUY_DISCRIMINATOR),
            Buffer.from(encodeU64(buyAmountLamports))
          ])
        });

        transaction.add(buyInstruction);
        log("Demande de signature dans Phantom...");
        const signed = await provider.signTransaction(transaction);
        const txid = await connection.sendRawTransaction(signed.serialize());
        log(`‚úÖ Achat envoy√© ! https://solscan.io/tx/${txid}`);

        // Surveillance pour revente
        const profitTarget = parseFloat(document.getElementById('profitTarget').value) || 50;
        const targetPrice = tokenData.priceSol * (1 + profitTarget / 100);
        monitorForSale(mintAddress, tokenData.priceSol, targetPrice, txid);

      } catch (err) {
        console.error(err);
        log(`‚ùå √âchec achat: ${err.message || err}`);
        alert(`‚ùå √âchec: ${err.message || 'Erreur inconnue'}`);
      }
    }

    // === REVENTE ===
    async function sellToken(mintAddress) {
      if (!provider || !connection) return;
      const priorityFeeLamports = parseInt(document.getElementById('priorityFee').value) || 1000000;

      try {
        const [pumpGlobal] = solanaWeb3.PublicKey.findProgramAddressSync(
          [Buffer.from("global")],
          new solanaWeb3.PublicKey(PUMP_PROGRAM_ID)
        );
        const [pumpTokenAccount] = solanaWeb3.PublicKey.findProgramAddressSync(
          [Buffer.from("token_account"), new solanaWeb3.PublicKey(mintAddress).toBuffer()],
          new solanaWeb3.PublicKey(PUMP_PROGRAM_ID)
        );
        const [userTokenAccount] = solanaWeb3.PublicKey.findProgramAddressSync(
          [
            provider.publicKey.toBuffer(),
            new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA").toBuffer(),
            new solanaWeb3.PublicKey(mintAddress).toBuffer()
          ],
          new solanaWeb3.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL")
        );

        const transaction = new solanaWeb3.Transaction();
        transaction.feePayer = provider.publicKey;
        const { blockhash } = await connection.getLatestBlockhash();
        transaction.recentBlockhash = blockhash;

        transaction.add(
          solanaWeb3.ComputeBudgetProgram.setComputeUnitLimit({ units: 200000 }),
          solanaWeb3.ComputeBudgetProgram.setComputeUnitPrice({ microLamports: priorityFeeLamports })
        );

        const sellInstruction = new solanaWeb3.TransactionInstruction({
          keys: [
            { pubkey: provider.publicKey, isSigner: true, isWritable: true },
            { pubkey: pumpGlobal, isSigner: false, isWritable: false },
            { pubkey: new solanaWeb3.PublicKey(PUMP_FEE_RECIPIENT), isSigner: false, isWritable: true },
            { pubkey: pumpTokenAccount, isSigner: false, isWritable: true },
            { pubkey: userTokenAccount, isSigner: false, isWritable: true },
            { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false },
            { pubkey: new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"), isSigner: false, isWritable: false },
            { pubkey: new solanaWeb3.PublicKey(RENT_SYSVAR), isSigner: false, isWritable: false }
          ],
          programId: new solanaWeb3.PublicKey(PUMP_PROGRAM_ID),
           Buffer.concat([Buffer.from(SELL_DISCRIMINATOR)])
        });

        transaction.add(sellInstruction);
        const signed = await provider.signTransaction(transaction);
        const txid = await connection.sendRawTransaction(signed.serialize());
        log(`‚úÖ Vente envoy√©e ! https://solscan.io/tx/${txid}`);
        alert(`‚úÖ Vente r√©ussie !\nhttps://solscan.io/tx/${txid}`);
      } catch (err) {
        console.error(err);
        log(`‚ùå √âchec vente: ${err.message || err}`);
      }
    }

    // === SURVEILLANCE POUR REVENTE ===
    function monitorForSale(mint, buyPrice, targetPrice, txid) {
      const check = async () => {
        try {
          const data = await getTokenData(mint);
          if (data && data.priceSol >= targetPrice) {
            log(`üéØ Profit atteint pour ${mint} ! Vente...`);
            sellToken(mint);
          } else {
            setTimeout(check, 5000);
          }
        } catch (err) {
          setTimeout(check, 10000); // R√©essayer en cas d'erreur
        }
      };
      check();
    }

    // === SCANNER ===
    async function pollForSignals() {
      try {
        const res = await fetch(WEBHOOK_URL);
        const data = await res.json();
        if (data.mint && data.mint !== lastMint) {
          lastMint = data.mint;
          buyToken(data.mint);
        }
      } catch (err) {
        console.error("Polling √©chou√©:", err);
      }
    }

    // === TOGGLE SCAN ===
    toggleScanBtn.onclick = () => {
      if (isScanning) {
        clearInterval(scanInterval);
        isScanning = false;
        toggleScanBtn.textContent = "‚ñ∂Ô∏è D√©marrer le Scan";
        log("‚èπÔ∏è Scan arr√™t√©");
      } else {
        isScanning = true;
        toggleScanBtn.textContent = "‚èπÔ∏è Arr√™ter le Scan";
        scanInterval = setInterval(pollForSignals, 3000);
        log("üîç Scan activ√©");
      }
    };
  </script>
</body>
</html>
