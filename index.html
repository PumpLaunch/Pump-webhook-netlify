<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>CryptoFlux Pro - Pump Sniper</title>
  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
  <style>
    :root {
      --bg: #0a0e27;
      --card: #131937;
      --border: #2a3457;
      --text: #ffffff;
      --green: #00ff88;
      --purple: #9945ff;
      --red: #ff3366;
      --orange: #ff9500;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, sans-serif;
      line-height: 1.5;
      padding: 16px;
    }
    .container { max-width: 700px; margin: 0 auto; }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }
    .logo {
      font-size: 1.6rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--purple), var(--green));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .btn-primary {
      background: linear-gradient(135deg, var(--purple), var(--green));
      color: white;
    }
    .btn-danger {
      background: var(--red);
      color: white;
    }
    .btn-secondary {
      background: var(--card);
      color: white;
      border: 1px solid var(--border);
    }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 1.2rem;
      margin-bottom: 1.2rem;
    }
    .alert {
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 12px;
      font-size: 0.9rem;
    }
    .alert-danger {
      background: rgba(255, 51, 102, 0.1);
      border: 1px solid var(--red);
      color: var(--red);
    }
    .alert-warning {
      background: rgba(255, 149, 0, 0.1);
      border: 1px solid var(--orange);
      color: var(--orange);
    }
    .alert-success {
      background: rgba(0, 255, 136, 0.1);
      border: 1px solid var(--green);
      color: var(--green);
    }
    .status {
      font-family: monospace;
      color: #8892b0;
      margin-top: 12px;
      font-size: 0.9rem;
      padding: 8px;
      background: rgba(0,0,0,0.3);
      border-radius: 6px;
    }
    label {
      display: block;
      margin: 8px 0 4px;
      font-weight: 500;
      font-size: 0.9rem;
    }
    input, select {
      width: 100%;
      padding: 8px;
      background: rgba(0,0,0,0.3);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: white;
      margin-bottom: 8px;
      font-family: monospace;
    }
    input:focus, select:focus {
      outline: none;
      border-color: var(--purple);
    }
    .stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      margin-bottom: 12px;
    }
    .stat {
      background: rgba(0,0,0,0.3);
      padding: 8px;
      border-radius: 6px;
      text-align: center;
    }
    .stat-label {
      font-size: 0.75rem;
      color: #8892b0;
    }
    .stat-value {
      font-size: 1.2rem;
      font-weight: 700;
      font-family: monospace;
    }
    .log {
      max-height: 200px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 0.85rem;
      background: rgba(0,0,0,0.3);
      padding: 8px;
      border-radius: 6px;
    }
    .log-item {
      padding: 4px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .log-time {
      color: #8892b0;
      margin-right: 8px;
    }
    .rate-limit-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px;
      background: rgba(0,0,0,0.3);
      border-radius: 6px;
      margin-top: 8px;
      font-size: 0.85rem;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="logo">‚ö° PUMP SNIPER</div>
      <button id="connectBtn" class="btn btn-primary" disabled>Connecter Wallet</button>
    </div>

    <div id="app" style="display:none;">
      <div class="card">
        <div class="alert alert-warning">
          <strong>‚ö†Ô∏è RATE LIMITING ACTIV√â</strong><br>
          Scan toutes les 10 secondes pour √©viter les limites API
        </div>
        
        <div class="stats">
          <div class="stat">
            <div class="stat-label">SOLDE</div>
            <div class="stat-value" id="balance">‚Äî SOL</div>
          </div>
          <div class="stat">
            <div class="stat-label">SCANN√âS</div>
            <div class="stat-value" id="scanned">0</div>
          </div>
          <div class="stat">
            <div class="stat-label">ACHATS</div>
            <div class="stat-value" id="bought">0</div>
          </div>
        </div>
        
        <div class="rate-limit-info">
          <span>Prochain scan: <strong id="nextScan">--</strong></span>
          <span>Intervalle: <strong id="scanInterval">10s</strong></span>
        </div>
        
        <div style="font-family: monospace; font-size: 0.85rem; color: #8892b0; margin-top: 8px;">
          <div><strong>Wallet:</strong> <span id="address">...</span></div>
          <div><strong>RPC:</strong> Helius Premium (rate limited)</div>
        </div>
      </div>

      <div class="card">
        <div class="alert alert-danger">
          <strong>‚ö†Ô∏è TRADING R√âEL</strong><br>
          Transactions irr√©versibles sur Solana Mainnet
        </div>

        <h3 style="margin-bottom: 12px;">‚öôÔ∏è Configuration</h3>
        
        <label>üí∞ Montant par achat (SOL):</label>
        <input type="number" id="buyAmount" value="0.05" step="0.01" min="0.01" max="1">
        
        <label>üë• D√©tenteurs minimum:</label>
        <input type="number" id="minHolders" value="20" min="5" max="200">
        
        <label>üìä Concentration max du top holder (%):</label>
        <input type="number" id="maxTopHolder" value="40" min="10" max="100">
        
        <label>‚è±Ô∏è Intervalle de scan (secondes):</label>
        <select id="scanIntervalSelect">
          <option value="5000">5 secondes (risque de rate limit)</option>
          <option value="10000" selected>10 secondes (recommand√©)</option>
          <option value="15000">15 secondes (s√ªr)</option>
          <option value="30000">30 secondes (tr√®s s√ªr)</option>
        </select>
        
        <label>‚ö° Frais de priorit√©:</label>
        <select id="priorityFee">
          <option value="50000">Moyen (0.00005 SOL)</option>
          <option value="100000" selected>√âlev√© (0.0001 SOL)</option>
          <option value="500000">Turbo (0.0005 SOL)</option>
          <option value="1000000">Extr√™me (0.001 SOL)</option>
        </select>
        
        <div style="margin-top: 16px; display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
          <button id="toggleScan" class="btn btn-primary">‚ñ∂Ô∏è D√©marrer</button>
          <button id="stopAll" class="btn btn-danger" style="display:none;">üõë Stop All</button>
        </div>
      </div>

      <div class="card">
        <h3 style="margin-bottom: 8px;">üìú Journal d'activit√©</h3>
        <div id="log" class="log"></div>
      </div>
    </div>

    <div id="status" class="status">V√©rification du wallet Phantom...</div>
  </div>

  <script>
    // ========================================
    // CONFIGURATION
    // ========================================
    
    const HELIUS_RPC_URL = 'https://mainnet.helius-rpc.com/?api-key=8f852e97-a557-4065-be74-cc2a6547cd28';
    const PUMP_PROGRAM_ID = '6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P';
    const PUMP_GLOBAL = '4wTV1YmiEkRvAtNtsSGPtUrqRYQMe5SKy2uB4Jjaxnjf';
    const PUMP_FEE_RECIPIENT = 'CebN5WGQ4jvEPvsVU4EoHEpgzq1VV7AbicfhtW4xC9iM';
    const TOKEN_PROGRAM = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
    const ASSOCIATED_TOKEN_PROGRAM = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL';
    const SYSTEM_PROGRAM = '11111111111111111111111111111111';
    const RENT_SYSVAR = 'SysvarRent111111111111111111111111111111111';
    
    const BUY_DISCRIMINATOR = [0x66, 0x06, 0x3d, 0x12, 0x01, 0xda, 0xeb, 0xea];
    
    // ========================================
    // VARIABLES GLOBALES
    // ========================================
    
    let provider = null;
    let connection = null;
    let isScanning = false;
    let scanInterval = null;
    let seenTokens = new Set();
    let stats = { scanned: 0, bought: 0 };
    let rateLimitCount = 0;
    let nextScanTime = 0;
    
    // √âl√©ments DOM
    const statusEl = document.getElementById('status');
    const connectBtn = document.getElementById('connectBtn');
    const toggleScanBtn = document.getElementById('toggleScan');
    const stopAllBtn = document.getElementById('stopAll');
    const addressEl = document.getElementById('address');
    const balanceEl = document.getElementById('balance');
    const scannedEl = document.getElementById('scanned');
    const boughtEl = document.getElementById('bought');
    const logEl = document.getElementById('log');
    const appEl = document.getElementById('app');
    const nextScanEl = document.getElementById('nextScan');
    const scanIntervalEl = document.getElementById('scanInterval');

    // ========================================
    // UTILITAIRES
    // ========================================
    
    function addLog(msg, type = 'info') {
      const now = new Date();
      const time = now.toLocaleTimeString('fr-FR');
      const color = type === 'error' ? 'var(--red)' : type === 'success' ? 'var(--green)' : type === 'warning' ? 'var(--orange)' : '#8892b0';
      
      const item = document.createElement('div');
      item.className = 'log-item';
      item.innerHTML = `<span class="log-time">[${time}]</span><span style="color:${color}">${msg}</span>`;
      logEl.insertBefore(item, logEl.firstChild);
      
      while (logEl.children.length > 50) {
        logEl.removeChild(logEl.lastChild);
      }
      
      console.log(`[${time}] ${msg}`);
      statusEl.textContent = msg;
    }

    function updateStats() {
      scannedEl.textContent = stats.scanned;
      boughtEl.textContent = stats.bought;
    }

    function updateNextScanTime() {
      if (!isScanning) {
        nextScanEl.textContent = '--';
        return;
      }
      
      const remaining = Math.max(0, Math.ceil((nextScanTime - Date.now()) / 1000));
      nextScanEl.textContent = `${remaining}s`;
    }

    async function updateBalance() {
      if (!provider || !connection) return;
      try {
        const balance = await connection.getBalance(provider.publicKey);
        const sol = (balance / solanaWeb3.LAMPORTS_PER_SOL).toFixed(4);
        balanceEl.textContent = `${sol} SOL`;
      } catch (err) {
        console.error('Erreur mise √† jour solde:', err);
      }
    }

    // ========================================
    // GESTION DU RATE LIMITING
    // ========================================
    
    async function safeRpcCall(fn, retries = 3, delay = 2000) {
      for (let i = 0; i < retries; i++) {
        try {
          return await fn();
        } catch (err) {
          if (err.message && err.message.includes('429')) {
            rateLimitCount++;
            addLog(`‚ö†Ô∏è Rate limit atteint (${rateLimitCount}x) - attente ${delay/1000}s...`, 'warning');
            
            if (i < retries - 1) {
              await new Promise(resolve => setTimeout(resolve, delay));
              delay *= 2; // Exponential backoff
            } else {
              throw err;
            }
          } else {
            throw err;
          }
        }
      }
    }

    // ========================================
    // CONNEXION WALLET
    // ========================================
    
    if (window.phantom?.solana?.isPhantom) {
      addLog("‚úÖ Phantom d√©tect√©");
      connectBtn.disabled = false;
      
      connectBtn.onclick = async () => {
        try {
          addLog("üîÑ Connexion...");
          provider = window.phantom.solana;
          
          const { publicKey } = await provider.connect();
          connection = new solanaWeb3.Connection(HELIUS_RPC_URL, 'confirmed');
          
          const pubKeyStr = publicKey.toString();
          addressEl.textContent = `${pubKeyStr.slice(0,6)}...${pubKeyStr.slice(-4)}`;
          
          await updateBalance();
          
          appEl.style.display = 'block';
          connectBtn.style.display = 'none';
          
          addLog("‚úÖ Connect√© avec succ√®s!", 'success');
          
          setInterval(updateBalance, 30000); // Toutes les 30 secondes
          setInterval(updateNextScanTime, 1000); // Chaque seconde
          
        } catch (err) {
          addLog(`‚ùå Erreur: ${err.message}`, 'error');
        }
      };
    } else {
      addLog("‚ùå Phantom non install√©", 'error');
      statusEl.innerHTML = '‚ùå Phantom requis<br><a href="https://phantom.app/" target="_blank" style="color:var(--purple)">Installer Phantom</a>';
    }

    // ========================================
    // ANALYSE DE TOKEN
    // ========================================
    
    async function analyzeToken(mintAddress) {
      try {
        const mint = new solanaWeb3.PublicKey(mintAddress);
        
        const largestAccounts = await safeRpcCall(async () => {
          return await connection.getTokenLargestAccounts(mint);
        });
        
        const holderCount = largestAccounts.value.length;
        const minHolders = parseInt(document.getElementById('minHolders').value) || 20;
        
        if (holderCount < minHolders) {
          addLog(`‚ö†Ô∏è ${mintAddress.slice(0, 8)}... - ${holderCount} holders < ${minHolders}`, 'warning');
          return null;
        }
        
        const topHolderPercent = largestAccounts.value[0] ? 
          (Number(largestAccounts.value[0].amount) / 1e15) * 100 : 0;
        
        const maxTopHolder = parseInt(document.getElementById('maxTopHolder').value) || 40;
        
        if (topHolderPercent > maxTopHolder) {
          addLog(`‚ö†Ô∏è ${mintAddress.slice(0, 8)}... - Top holder ${topHolderPercent.toFixed(0)}% > ${maxTopHolder}%`, 'warning');
          return null;
        }
        
        return {
          mint: mintAddress,
          holderCount,
          topHolderPercent,
          score: holderCount >= 50 ? 90 : holderCount >= 30 ? 80 : 70
        };
        
      } catch (err) {
        console.error('Erreur analyse:', err);
        return null;
      }
    }

    // ========================================
    // ACHAT DE TOKEN
    // ========================================
    
    async function buyToken(tokenData) {
      if (!provider || !connection) {
        addLog("‚ùå Wallet non connect√©", 'error');
        return false;
      }

      const mintAddress = tokenData.mint;
      const buyAmountSol = parseFloat(document.getElementById('buyAmount').value) || 0.05;
      const priorityFeeMicroLamports = parseInt(document.getElementById('priorityFee').value) || 100000;

      try {
        addLog(`üîÑ Achat ${mintAddress.slice(0, 8)}... (${buyAmountSol} SOL)`, 'info');
        
        const mint = new solanaWeb3.PublicKey(mintAddress);
        const buyAmountLamports = Math.floor(buyAmountSol * solanaWeb3.LAMPORTS_PER_SOL);
        
        const [bondingCurve] = solanaWeb3.PublicKey.findProgramAddressSync(
          [Buffer.from('bonding-curve'), mint.toBuffer()],
          new solanaWeb3.PublicKey(PUMP_PROGRAM_ID)
        );
        
        const [associatedBondingCurve] = solanaWeb3.PublicKey.findProgramAddressSync(
          [
            bondingCurve.toBuffer(),
            new solanaWeb3.PublicKey(TOKEN_PROGRAM).toBuffer(),
            mint.toBuffer(),
          ],
          new solanaWeb3.PublicKey(ASSOCIATED_TOKEN_PROGRAM)
        );
        
        const [associatedUser] = solanaWeb3.PublicKey.findProgramAddressSync(
          [
            provider.publicKey.toBuffer(),
            new solanaWeb3.PublicKey(TOKEN_PROGRAM).toBuffer(),
            mint.toBuffer(),
          ],
          new solanaWeb3.PublicKey(ASSOCIATED_TOKEN_PROGRAM)
        );
        
        const transaction = new solanaWeb3.Transaction();
        
        transaction.add(
          solanaWeb3.ComputeBudgetProgram.setComputeUnitPrice({
            microLamports: priorityFeeMicroLamports
          })
        );
        
        transaction.add(
          solanaWeb3.ComputeBudgetProgram.setComputeUnitLimit({
            units: 100000
          })
        );
        
        const ataInfo = await safeRpcCall(async () => {
          return await connection.getAccountInfo(associatedUser);
        });
        
        if (!ataInfo) {
          addLog(`üî® ATA inexistant - sera cr√©√© lors de l'achat`, 'info');
        }
        
        const amountBuffer = Buffer.alloc(8);
        amountBuffer.writeBigUInt64LE(BigInt(buyAmountLamports), 0);
        
        const maxSolBuffer = Buffer.alloc(8);
        maxSolBuffer.writeBigUInt64LE(BigInt(buyAmountLamports), 0);
        
        const instructionData = Buffer.concat([
          Buffer.from(BUY_DISCRIMINATOR),
          amountBuffer,
          maxSolBuffer
        ]);
        
        const keys = [
          { pubkey: new solanaWeb3.PublicKey(PUMP_GLOBAL), isSigner: false, isWritable: false },
          { pubkey: new solanaWeb3.PublicKey(PUMP_FEE_RECIPIENT), isSigner: false, isWritable: true },
          { pubkey: mint, isSigner: false, isWritable: false },
          { pubkey: bondingCurve, isSigner: false, isWritable: true },
          { pubkey: associatedBondingCurve, isSigner: false, isWritable: true },
          { pubkey: associatedUser, isSigner: false, isWritable: true },
          { pubkey: provider.publicKey, isSigner: true, isWritable: true },
          { pubkey: new solanaWeb3.PublicKey(SYSTEM_PROGRAM), isSigner: false, isWritable: false },
          { pubkey: new solanaWeb3.PublicKey(TOKEN_PROGRAM), isSigner: false, isWritable: false },
          { pubkey: new solanaWeb3.PublicKey(RENT_SYSVAR), isSigner: false, isWritable: false }
        ];
        
        const buyInstruction = new solanaWeb3.TransactionInstruction({
          keys,
          programId: new solanaWeb3.PublicKey(PUMP_PROGRAM_ID),
          data: instructionData
        });
        
        transaction.add(buyInstruction);
        
        const { blockhash } = await safeRpcCall(async () => {
          return await connection.getLatestBlockhash();
        });
        
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = provider.publicKey;
        
        addLog("‚úçÔ∏è Signature...", 'info');
        const signed = await provider.signTransaction(transaction);
        
        addLog("üì§ Envoi...", 'info');
        const signature = await safeRpcCall(async () => {
          return await connection.sendRawTransaction(signed.serialize(), {
            skipPreflight: false,
            preflightCommitment: 'confirmed'
          });
        });
        
        addLog(`üîó https://solscan.io/tx/${signature}`, 'info');
        
        const confirmation = await safeRpcCall(async () => {
          return await connection.confirmTransaction(signature);
        });
        
        if (confirmation.value.err) {
          throw new Error('Transaction √©chou√©e');
        }
        
        addLog(`‚úÖ ACHAT CONFIRM√â! ${mintAddress.slice(0, 8)}...`, 'success');
        stats.bought++;
        updateStats();
        await updateBalance();
        
        return true;
        
      } catch (err) {
        console.error('Erreur achat:', err);
        addLog(`‚ùå √âchec: ${err.message}`, 'error');
        return false;
      }
    }

    // ========================================
    // SCANNER
    // ========================================
    
    async function scanForNewTokens() {
      try {
        const signatures = await safeRpcCall(async () => {
          return await connection.getSignaturesForAddress(
            new solanaWeb3.PublicKey(PUMP_PROGRAM_ID),
            { limit: 5 } // R√©duit √† 5 pour √©viter rate limiting
          );
        });
        
        stats.scanned += signatures.length;
        updateStats();
        
        for (const sig of signatures) {
          if (seenTokens.has(sig.signature)) continue;
          seenTokens.add(sig.signature);
          
          const tx = await safeRpcCall(async () => {
            return await connection.getParsedTransaction(sig.signature, {
              maxSupportedTransactionVersion: 0
            });
          });
          
          if (!tx) continue;
          
          const instructions = tx.transaction.message.instructions;
          
          for (const ix of instructions) {
            if (ix.programId.toString() === PUMP_PROGRAM_ID) {
              const accounts = ix.accounts;
              if (accounts && accounts.length > 2) {
                const mint = accounts[2].toString();
                
                addLog(`üÜï ${mint.slice(0, 8)}...`, 'info');
                
                const tokenData = await analyzeToken(mint);
                
                if (tokenData) {
                  addLog(`‚úÖ Valid√©! Score:${tokenData.score} Holders:${tokenData.holderCount}`, 'success');
                  await buyToken(tokenData);
                }
              }
            }
          }
        }
        
      } catch (err) {
        console.error('Erreur scan:', err);
        if (!err.message.includes('429')) {
          addLog(`‚ö†Ô∏è Erreur: ${err.message}`, 'warning');
        }
      }
    }

    // ========================================
    // CONTR√îLES
    // ========================================
    
    toggleScanBtn.onclick = () => {
      if (!isScanning) {
        const intervalMs = parseInt(document.getElementById('scanIntervalSelect').value) || 10000;
        scanIntervalEl.textContent = `${intervalMs/1000}s`;
        
        isScanning = true;
        toggleScanBtn.textContent = "‚è∏Ô∏è Pause";
        toggleScanBtn.className = "btn btn-secondary";
        stopAllBtn.style.display = "block";
        
        addLog("üöÄ SCANNER D√âMARR√â", 'success');
        
        scanInterval = setInterval(() => {
          nextScanTime = Date.now() + intervalMs;
          scanForNewTokens();
        }, intervalMs);
        
        nextScanTime = Date.now() + intervalMs;
        scanForNewTokens();
        
      } else {
        isScanning = false;
        toggleScanBtn.textContent = "‚ñ∂Ô∏è D√©marrer";
        toggleScanBtn.className = "btn btn-primary";
        
        if (scanInterval) {
          clearInterval(scanInterval);
          scanInterval = null;
        }
        
        addLog("‚è∏Ô∏è Pause", 'warning');
      }
    };

    stopAllBtn.onclick = () => {
      isScanning = false;
      toggleScanBtn.textContent = "‚ñ∂Ô∏è D√©marrer";
      toggleScanBtn.className = "btn btn-primary";
      stopAllBtn.style.display = "none";
      
      if (scanInterval) {
        clearInterval(scanInterval);
        scanInterval = null;
      }
      
      seenTokens.clear();
      stats = { scanned: 0, bought: 0 };
      rateLimitCount = 0;
      updateStats();
      
      addLog("üõë ARR√äT COMPLET", 'error');
    };

    window.addEventListener('beforeunload', () => {
      if (scanInterval) clearInterval(scanInterval);
    });
  </script>
</body>
</html>
